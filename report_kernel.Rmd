---
title: "Descriptive Statistics and Graphics"
---


```{r setup, include=FALSE}
library(reticulate)
virtualenv_create('shiny-app-env', python= 'python3')
use_virtualenv('shiny-app-env', required = T)
virtualenv_install('shiny-app-env', packages = c('seaborn'))
virtualenv_install('shiny-app-env', packages = c('scipy'))
```


```{r, echo = FALSE, comment='', message = FALSE, error = TRUE, warning=FALSE}
library(knitr) 

# Get data
df <- params$data
df_code <- df

# Initialize further chunks
eval0 <- FALSE

tryCatch({
  
  df <- df[,params$vars1,drop=FALSE]
  df2 <- df
  
  # Initialize next computations
  eval0 <- TRUE

}, error=function(e) {
  
  stop(safeError("Please try other column names for the following columns: "))
}

)

if (length(setdiff(params$vars1,colnames(df))) >0) {
  equal <- intersect(colnames(df),params$vars1)
  kable(setdiff(params$vars1,equal),col.names = "Column")
}
```


```{r, eval=eval0, echo = FALSE, comment='', message = FALSE, error = TRUE, warning=FALSE}
# Initialize next computations
eval <- FALSE
eval_rows <- FALSE

tryCatch({
  
# Drop columns if all observations are missing 
col_names_missing <- sapply(df, function(col) all(is.na(col)))
df[ ,col_names_missing] <- list(NULL)
df_list <- df 

# Drop empty rows
rowsums <- data.frame(sapply(df,is.na))
if (length(which(rowSums(rowsums) == dim(df)[2])) != 0L){
  eval_rows <- TRUE
  rows_drop <- (which(rowSums(rowsums) == dim(df)[2]))
  length_non_complete <- length(which(rowSums(rowsums) == dim(df)[2]))
  df <- df[-rows_drop, ,drop=FALSE]
}

# Convert logical variables to character
cols_logical <- sapply(df, function(col) is.logical(col))
df[ ,cols_logical] <- sapply(df[ ,cols_logical], as.character)

# Convert numerical variables with less than 7 unique values to character (missing values omitted)
col_names_numeric <- sapply(df, function(col) length(unique(na.omit(col))) < 7L & is.numeric(col))
df[ ,col_names_numeric] <- sapply(df[ ,col_names_numeric], as.character)

# Extract numerical variables and sort by variable
df_num <- df[which(sapply(df, is.numeric) == 1L)]
df_num <- df_num[,order(colnames(df_num)),drop=FALSE] 

# Extract approximate continuous variables and non-continuous var
if (ncol(df_num)>0){

  rateunique_df <- sapply(df_num, function(col) continuous(col))
  cols_continuous <- names(which(rateunique_df == TRUE))
  df_cont <- df_num[,rateunique_df,drop=FALSE] # numeric, continuous resp. assumption fulfilled 
  df_noncont <- df_num[,!rateunique_df,drop=FALSE] # numeric, non-continuous 
  
} 

# Extract character variables 
df_factor <- df[which(sapply(df, is.character) == 1L)]

# Categorical 
if (exists("df_noncont")){
  df_cat <- merge(df_factor, df_noncont, by="row.names")
  df_cat$Row.names <- NULL
  df_cat$Row.names.y <- NULL
} else {
  df_cat <- df_factor
}

# Initialize next computations
eval <- TRUE

}, error=function(e) {
  
  stop(safeError("Dataset cannot be prepared. Please check the data for consistency."))
  
}

)
```


```{r, results="asis", eval=eval, echo = FALSE, comment='', message = FALSE, error = TRUE, warning=FALSE}
# Call used libraries 
library(kableExtra)

# Chunk with first page of basic information
cat("\n# Basic Information", fill=TRUE)
cat("\\small ", fill=TRUE)
cat("Automatic statistics for the file:", fill=TRUE)
dataname <- params$filename[1]
kable(dataname, col.names = "File", linesep = '', longtable=T) 

cat("Your selection for the encoding:", fill=TRUE)
if (params$fencoding=="unknown"){
  cat("Auto")
} else {cat("UTF-8")}
cat("\\newline",fill=TRUE) 

cat("Your selection for the decimal character:", fill=TRUE)
if (params$decimal=="auto"){
  cat("Auto")
} else {cat(params$decimal)}
cat("\\newline",fill=TRUE) 
  
cat("Observations (rows with at least one non-missing value): ", fill=TRUE)
cat(dim(df)[1])
cat("\\newline",fill=TRUE) 

# Missing rows
if (exists("length_non_complete")){
  cat("Number of rows that are dropped because they contain no values (all values are missing):", length_non_complete)
  cat("\\newline",fill=TRUE) 
}

cat("Variables (columns with at least one non-missing value): ", fill=TRUE)
cat(dim(df_list)[2])
cat("\\newline",fill=TRUE) 


# Missing columns
if (exists("col_names_missing")){
  if (sum(col_names_missing) != 0L){
    cat("Number of columns that are dropped because they contain no values (all values are missing):", sum(col_names_missing), fill=TRUE)
    cat("\\newline",fill=TRUE) 
  } 
}


if (exists("df_cont")){
  cat("Variables considered continuous: ", fill=TRUE)
  if (ncol(df_cont)>0){
    cat(ncol(df_cont),fill=TRUE)
    knitr::kable(cols_continuous, col.names = "Variables considered continuous", linesep = '', longtable=T) %>%
      kable_styling(font_size = 8, position = "center", full_width = FALSE, latex_options = c("HOLD_position","repeat_header"))
  } else {
    cat("0", fill=TRUE)
    cat("\\newline",fill=TRUE) 
  }
}


if (exists("df_cat")){
  cat("Variables considered categorical: ", fill=TRUE)
  if (ncol(df_cat)>0){
    cat(ncol(df_cat),fill=TRUE)
    knitr::kable(colnames(df_cat), col.names = "Variables considered categorical", linesep = '', longtable=T) %>%
      kable_styling(font_size = 8, position = "center", full_width = FALSE, latex_options = c("HOLD_position","repeat_header"))
  } else {
    cat("0", fill=TRUE)
    cat("\\newline",fill=TRUE) 
  }
}
```


```{r, results="asis", eval=eval, echo = FALSE, comment='', message = FALSE, error = TRUE, warning=FALSE}
# Numeric falsly to char? 
check_reading <- function(col){
  numeric <- !is.na(as.numeric(col))
  return(sum(numeric)/sum(!is.na(col)))
}

df_char2 <- df2[which(sapply(df2, is.character) == 1L)]
numeric_percent <- sapply(df_char2, function(col) check_reading(col))

if (length(numeric_percent[(numeric_percent>0.9)]) != 0L){
  cat("**Warning: More than 90% of the values of these columns could be treated as numeric. Nevertheless, because of some values or the selected decimal character, the columns must be treated as discrete. Are all the values plausible? Please check the data once more before uploading! Column(s):**", names(numeric_percent[(numeric_percent>0.9)]), fill=TRUE)
}

```

\pagebreak

```{r, eval=eval, echo = FALSE, comment='', message = FALSE, error = TRUE, warning=FALSE}
# Instead of updating the rest of the code:
if (exists("df_cont")) df_num <- df_cont
if (exists("df_cat")) df_factor <- df_cat
```


```{r, results="asis", eval=eval, echo = FALSE, comment='', message = FALSE, error = TRUE, warning=FALSE}
# Title 
if (exists("df_num")){
  if (dim(df_num)[2] != 0L){
    eval_num <- TRUE
    cat("# Results for Numerical Variables", fill=TRUE)
    cat("## Descriptive Statistics", fill=TRUE)
    cat("Variables are sorted alphabetically. Missings are omitted in the stats. CV only for positive variables. ", fill=TRUE)
   
  } 
}
```

```{r, eval=eval_num, echo = FALSE, comment='', message = FALSE, error = TRUE, warning=FALSE}
main <- import_main()
main$df_num <- r_to_py(df_num)
```

```{python, eval=eval_num, echo = FALSE, comment='', message = FALSE, error = TRUE, warning=FALSE}
import numpy as np
import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt 
from scipy import stats 

# Set console printing options 
pd.set_option('display.max_rows', 500)
pd.set_option('display.max_columns', 20)
pd.set_option('display.width', 1000)


# Continuous variables
## Descriptive statistics
df_num_stats = df_num.describe()
df_num_stats = df_num_stats.transpose()
df_num_stats.rename(columns={"count": "N Obs", "mean": "Mean", "50%": "Median", 
                             "std": "SD", "min": "Min", "max": "Max"}, inplace=True)
df_num_stats["N Obs"] = df_num_stats["N Obs"].astype('int64') 
df_num_stats.drop(columns=['25%', '75%'], inplace=True)
df_num_stats["N Missing"] = df_num.isna().sum()
df_num_stats["N Valid"] = (df_num_stats["N Obs"] - df_num_stats["N Missing"])
df_num_stats["% Complete"] = (df_num_stats["N Valid"] / df_num_stats["N Obs"])*100
df_num_stats["N Unique"] = df_num.nunique()
df_num_stats["MAD"] = df_num.mad(axis=0)
df_num_stats["Skewness"] = df_num.skew(axis=0)
df_num_stats["Kurtosis"] = df_num.kurtosis(axis=0)
df_num_stats.loc[df_num_stats["Min"]>0,"CV"] = df_num_stats["SD"] / df_num_stats["Mean"]
df_num_stats = df_num_stats.round(2)

### Reorder columns to be similar to the output of the R app 
df_num_stats = df_num_stats.reindex(columns=["N Obs", "N Missing", "N Valid", 
                                             "% Complete", "N Unique", "Mean", 
                                             "SD", "Median", "MAD", "Min", "Max", 
                                             "Skewness", "Kurtosis", "CV"]) 

### Order by variable name
df_num_stats.sort_index(inplace=True)

### Output
df_num_stats
```

\pagebreak


```{r, results="asis", eval=eval_num, echo = FALSE, comment='', message = FALSE, error = TRUE, warning=FALSE}
if (exists("df_num")){
  if (dim(df_num)[2] > 1){
    cat("## Graphics", fill=TRUE)
    cat("### Histograms", fill=TRUE)
    if(dim(df_num)[2]> 1){
      cat("One Density Histogram per page for each variable. Variables are sorted alphabetically. The blue line represents the normal density approximation. The green line represents a special kernel density approximation.  ", fill=TRUE)
    }
  } 
}
```

```{r, results="asis", eval=eval_num, echo = FALSE, comment='', message = FALSE, error = TRUE, warning=FALSE}
if (exists("df_num")){
  if (dim(df_num)[2] == 1){
    cat("## Graphics", fill=TRUE)
    cat("### Histograms", fill=TRUE)
    eval_num <- TRUE
    if(dim(df_num)[2]==1){
      cat("Density Histogram. The blue line represents the normal density approximation. The green line represents a special kernel density approximation.  ", fill=TRUE)
    }
  } 
}
```

```{python, eval=eval_num, echo = FALSE, comment='', message = FALSE, error = TRUE, warning=FALSE, fig.dim = c(14,8)}
## Histograms Large
def histo(ax, var):
    sns.histplot(df_num.iloc[:,var], ax = ax, stat='density', 
                 color = '#2fa42d', kde = True, 
                 bins = len(np.unique(df_num.iloc[:,var]))//2)
    xaxis = np.arange(min(df_num.iloc[:,var]), max(df_num.iloc[:,var]), 0.001)
    fit_normal = stats.norm.pdf(xaxis, df_num.iloc[:,var].mean(), df_num.iloc[:,var].std())    
    ax.plot(xaxis, fit_normal, 'r', lw = 1, color = '#396e9f')
    ax.set_xlabel(df_num.columns[var], fontsize=25)


for var in range(df_num.shape[1]):
  fig, ax = plt.subplots(nrows = 1, ncols=1)
  histo(ax, var)
  plt.show()
```



